import { AstNodeType } from "./AstNodeType";
import { ISymbolPosition } from "../shared/ISymbolPosition";
import { ICodeToken } from "../shared/ICodeToken";
import { IAstToken, IAstKeyword, IAstText, IAstOperator, IAstProgram, IAstModule, IAstNode, IAstCommentLine, IAstCommentBlock, IAstNumber, IAstString, IAstBoolean, IAstArray, IAstIdentifier, IAstRawIdentifier, IAstIdentifierScope, IAstFunctionDeclaration, IAstVariableDeclaration, IAstPropertyDeclaration, IAstStatement, IAstBreakStatement, IAstReturnStatement, IAstContinueStatement, IAstBlockStatement, IAstIfStatement, IAstSwitchStatement, IAstCaseStatement, IAstWhileStatement, IAstDoWhileStatement, IAstForStatement, IAstForInStatement, IAstImportStatement, IAstExpressionStatement, IAstParenExpression, IAstObjectExpression, IAstCallExpression, IAstOperationExpression, IAstUpdateExpression, IAstBinaryExpression, IAstMemberExpression, IAstIndexerExpression, IAstOuterStatement, IAstTextLineStatement, IAstObjectLineStatement, IAstStringIncludeStatement, IAstPrototypeExpression, IAstScope, IAstTokenSequence, IAstConditionalExpression, IAstFinallyStatement, IAstCatchStatement, IAstTryStatement, IAstNewExpression, IAstThrowStatement, IAstDebuggerKeyword, IAstDeleteExpression, IAstDeleteLineExpression, IAstContextIdentifier, IAstTypeofExpression } from "./IAstNode";
import { KeywordType } from "./KeywordType";
import { OperatorType } from "./OperatorType";
import { VariableDeclarationKind } from "./VariableDeclarationKind";
export declare const astFactory: {
    token: (token: ICodeToken, start: ISymbolPosition) => IAstToken;
    tokenSequence: (tokens: ICodeToken[], start: ISymbolPosition, end: ISymbolPosition) => IAstTokenSequence;
    keyword: (keywordType: KeywordType, start: ISymbolPosition, end: ISymbolPosition) => IAstKeyword;
    debuggerKeyword: (keywordType: KeywordType, start: ISymbolPosition, end: ISymbolPosition) => IAstDebuggerKeyword;
    text: (text: string, start: ISymbolPosition, end: ISymbolPosition) => IAstText;
    operator: (operatorType: OperatorType, value: string, start: ISymbolPosition, end: ISymbolPosition) => IAstOperator;
    module: (tokens: ICodeToken[], content: IAstProgram, imports: IAstImportStatement[], modulePath: string) => IAstModule;
    program: (content: IAstNode[], start: ISymbolPosition, end: ISymbolPosition) => IAstProgram;
    commentLine: (text: string, start: ISymbolPosition, end: ISymbolPosition) => IAstCommentLine;
    commentBlock: (text: string, start: ISymbolPosition, end: ISymbolPosition) => IAstCommentBlock;
    numberLiteral: (value: number, start: ISymbolPosition, end: ISymbolPosition) => IAstNumber;
    stringLiteral: (value: IAstNode[], allowIncludes: boolean, start: ISymbolPosition, end: ISymbolPosition) => IAstString;
    booleanLiteral: (value: boolean, start: ISymbolPosition, end: ISymbolPosition) => IAstBoolean;
    arrayLiteral: (value: IAstNode[], start: ISymbolPosition, end: ISymbolPosition) => IAstArray;
    identifier: (value: string, start: ISymbolPosition, end: ISymbolPosition) => IAstIdentifier;
    rawIndentifier: (value: IAstNode, start: ISymbolPosition, end: ISymbolPosition) => IAstRawIdentifier;
    contextIndentifier: (value: IAstNode, start: ISymbolPosition, end: ISymbolPosition) => IAstContextIdentifier;
    IdentifierScope: (value: IAstNode[], start: ISymbolPosition, end: ISymbolPosition) => IAstIdentifierScope;
    functionDeclaration: (args: IAstNode[], body: IAstProgram, isLambda: boolean, start: ISymbolPosition, end: ISymbolPosition) => IAstFunctionDeclaration;
    variableDeclaration: (identifier: IAstNode, kind: VariableDeclarationKind, value: IAstNode, start: ISymbolPosition, end: ISymbolPosition) => IAstVariableDeclaration;
    propertyDeclaration: (identifier: IAstNode, value: IAstNode, start: ISymbolPosition, end: ISymbolPosition) => IAstPropertyDeclaration;
    statement: (statement: IAstNode, start: ISymbolPosition, end: ISymbolPosition) => IAstStatement;
    breakStatement: (start: ISymbolPosition, end: ISymbolPosition) => IAstBreakStatement;
    returnStatement: (value: IAstNode, start: ISymbolPosition, end: ISymbolPosition) => IAstReturnStatement;
    continueStatement: (start: ISymbolPosition, end: ISymbolPosition) => IAstContinueStatement;
    blockStatement: (content: IAstNode[], start: ISymbolPosition, end: ISymbolPosition, withoutBraces?: boolean) => IAstBlockStatement;
    ifStatement: (condition: IAstNode, thenValue: IAstNode, elseValue: IAstNode, start: ISymbolPosition, end: ISymbolPosition) => IAstIfStatement;
    switchStatement: (condition: IAstNode, cases: IAstNode[], start: ISymbolPosition, end: ISymbolPosition) => IAstSwitchStatement;
    caseStatement: (condition: IAstNode, body: IAstNode[], consequent: IAstNode, start: ISymbolPosition, end: ISymbolPosition) => IAstCaseStatement;
    whileStatement: (condition: IAstNode, body: IAstNode, start: ISymbolPosition, end: ISymbolPosition) => IAstWhileStatement;
    doWhileStatement: (condition: IAstNode, body: IAstNode, start: ISymbolPosition, end: ISymbolPosition) => IAstDoWhileStatement;
    forStatement: (init: IAstNode, test: IAstNode, update: IAstNode, body: IAstNode, start: ISymbolPosition, end: ISymbolPosition) => IAstForStatement;
    forInStatement: (left: IAstNode, right: IAstNode, body: IAstNode, start: ISymbolPosition, end: ISymbolPosition) => IAstForInStatement;
    importStatement: (alias: IAstNode, identifier: IAstNode, importInContext: boolean, path: IAstNode, start: ISymbolPosition, end: ISymbolPosition) => IAstImportStatement;
    tryStatement: (body: IAstNode, catchClause: IAstNode, finallyBlock: IAstNode, start: ISymbolPosition, end: ISymbolPosition) => IAstTryStatement;
    catchStatement: (body: IAstNode, varDeclaration: IAstNode, start: ISymbolPosition, end: ISymbolPosition) => IAstCatchStatement;
    finallyStatement: (body: IAstNode, start: ISymbolPosition, end: ISymbolPosition) => IAstFinallyStatement;
    throwStatement: (expression: IAstNode, start: ISymbolPosition, end: ISymbolPosition) => IAstThrowStatement;
    expressionStatement: (expression: IAstNode, start: ISymbolPosition, end: ISymbolPosition) => IAstExpressionStatement;
    parenExpression: (expression: IAstNode, start: ISymbolPosition, end: ISymbolPosition) => IAstParenExpression;
    objectExpression: (properties: IAstNode[], start: ISymbolPosition, end: ISymbolPosition) => IAstObjectExpression;
    callExpression: (calee: IAstNode, args: IAstNode[], start: ISymbolPosition, end: ISymbolPosition) => IAstCallExpression;
    operationExpression: (operation: IAstNode, start: ISymbolPosition, end: ISymbolPosition) => IAstOperationExpression;
    updateExpression: (argument: IAstNode, operator: IAstNode, prefix: boolean, start: ISymbolPosition, end: ISymbolPosition) => IAstUpdateExpression;
    binaryExpression: (left: IAstNode, operator: IAstNode, right: IAstNode, start: ISymbolPosition, end: ISymbolPosition) => IAstBinaryExpression;
    memberExpression: (object: IAstNode, property: IAstNode, computed: boolean, start: ISymbolPosition, end: ISymbolPosition) => IAstMemberExpression;
    IndexerExpression: (member: IAstMemberExpression, start: ISymbolPosition, end: ISymbolPosition) => IAstIndexerExpression;
    conditionalExpression: (condition: IAstNode, whenTrue: IAstNode, whenFalse: IAstNode, colonToken: IAstNode, questionToken: IAstNode, start: ISymbolPosition, end: ISymbolPosition) => IAstConditionalExpression;
    newExpression: (expression: IAstNode, start: ISymbolPosition, end: ISymbolPosition) => IAstNewExpression;
    deleteExpression: (expression: IAstNode, start: ISymbolPosition, end: ISymbolPosition) => IAstDeleteExpression;
    typeofExpression: (expression: IAstNode, start: ISymbolPosition, end: ISymbolPosition) => IAstTypeofExpression;
    outerStatement: (indent: number, statement: IAstNode, start: ISymbolPosition, end: ISymbolPosition) => IAstOuterStatement;
    textLineStatement: (indent: number, text: IAstNode[], start: ISymbolPosition, end: ISymbolPosition) => IAstTextLineStatement;
    objectLineStatement: (object: IAstNode, value: IAstNode, tags: IAstNode[], start: ISymbolPosition, end: ISymbolPosition) => IAstObjectLineStatement;
    stringIncludeStatement: (expression: IAstNode, start: ISymbolPosition, end: ISymbolPosition) => IAstStringIncludeStatement;
    prototypeExpression: (value: IAstNode, start: ISymbolPosition, end: ISymbolPosition) => IAstPrototypeExpression;
    deleteLineExpression: (object: IAstNode, start: ISymbolPosition, end: ISymbolPosition) => IAstDeleteLineExpression;
    scope: (content: IAstNode[], open: IAstNode, close: IAstNode, start: ISymbolPosition, end: ISymbolPosition) => IAstScope;
    tag: (content: IAstNode[], open: IAstNode, close: IAstNode, start: ISymbolPosition, end: ISymbolPosition) => IAstScope;
    asNode: <TAst extends IAstNode>(ast: IAstNode, nodeType: AstNodeType) => TAst;
};
