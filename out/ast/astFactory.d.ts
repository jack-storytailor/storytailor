import { AstNodeType } from "./AstNodeType";
import { ISymbolPosition } from "../shared/ISymbolPosition";
import { ICodeToken } from "../shared/ICodeToken";
import { IAstToken, IAstKeyword, IAstText, IAstOperator, IAstProgram, IAstModule, IAstNode, IAstCommentLine, IAstCommentBlock, IAstNumber, IAstString, IAstBoolean, IAstArray, IAstIdentifier, IAstRawIdentifier, IAstIdentifierScope, IAstPropertyDeclaration, IAstBreakStatement, IAstContinueStatement, IAstBlockStatement, IAstIfStatement, IAstSwitchStatement, IAstCaseStatement, IAstWhileStatement, IAstDoWhileStatement, IAstForStatement, IAstForInStatement, IAstImportStatement, IAstParenExpression, IAstObject, IAstCallExpression, IAstUpdateExpression, IAstBinaryExpression, IAstMemberExpression, IAstIndexerExpression, IAstOuterStatement, IAstTextLineStatement, IAstObjectLineStatement, IAstStringIncludeStatement, IAstPrototypeExpression, IAstScope, IAstTokenSequence, IAstConditionalExpression, IAstFinallyStatement, IAstCatchStatement, IAstTryStatement, IAstThrowStatement, IAstDebuggerKeyword, IAstDeleteLineExpression, IAstContextIdentifier, IAstRegexLiteral, IAstVariableDeclaration, IAstRawImportStatement, IAstImportItem, IAstClassDeclaration, IAstKeywordNode, IAstFunction, IAstDeconstructingAssignment } from "./IAstNode";
import { KeywordType } from "./KeywordType";
import { OperatorType } from "./OperatorType";
import { VariableDeclarationKind } from "./VariableDeclarationKind";
export declare const astFactory: {
    token: (token: ICodeToken, start: ISymbolPosition) => IAstToken;
    tokenSequence: (tokens: ICodeToken[], start: ISymbolPosition, end: ISymbolPosition) => IAstTokenSequence;
    keyword: (keywordType: KeywordType, start: ISymbolPosition, end: ISymbolPosition) => IAstKeyword;
    debuggerKeyword: (keywordType: KeywordType, start: ISymbolPosition, end: ISymbolPosition) => IAstDebuggerKeyword;
    text: (text: string, start: ISymbolPosition, end: ISymbolPosition) => IAstText;
    operator: (operatorType: OperatorType, value: string, start: ISymbolPosition, end: ISymbolPosition) => IAstOperator;
    module: (tokens: ICodeToken[], content: IAstProgram, imports: IAstImportStatement[], modulePath: string) => IAstModule;
    program: (content: IAstNode[], start: ISymbolPosition, end: ISymbolPosition) => IAstProgram;
    commentLine: (text: string, start: ISymbolPosition, end: ISymbolPosition) => IAstCommentLine;
    commentBlock: (text: string, start: ISymbolPosition, end: ISymbolPosition) => IAstCommentBlock;
    numberLiteral: (value: number, start: ISymbolPosition, end: ISymbolPosition) => IAstNumber;
    stringLiteral: (value: IAstNode[], allowIncludes: boolean, start: ISymbolPosition, end: ISymbolPosition) => IAstString;
    regexLiteral: (value: string, start: ISymbolPosition, end: ISymbolPosition) => IAstRegexLiteral;
    booleanLiteral: (value: boolean, start: ISymbolPosition, end: ISymbolPosition) => IAstBoolean;
    arrayLiteral: (value: IAstNode[], start: ISymbolPosition, end: ISymbolPosition) => IAstArray;
    functionLiteral: (name: IAstNode, args: IAstNode[], body: IAstNode, isLambda: boolean, isAsync: boolean, isNoKeyword: boolean, isGenerator: boolean, start: ISymbolPosition, end: ISymbolPosition) => IAstFunction;
    identifier: (value: string, isJsIdentifier: boolean, start: ISymbolPosition, end: ISymbolPosition) => IAstIdentifier;
    rawIndentifier: (value: IAstNode, start: ISymbolPosition, end: ISymbolPosition) => IAstRawIdentifier;
    contextIndentifier: (value: IAstNode, start: ISymbolPosition, end: ISymbolPosition) => IAstContextIdentifier;
    IdentifierScope: (value: IAstNode[], start: ISymbolPosition, end: ISymbolPosition) => IAstIdentifierScope;
    variableListDeclaration: (identifiers: IAstNode[], kind: VariableDeclarationKind, value: IAstNode, start: ISymbolPosition, end: ISymbolPosition) => IAstVariableDeclaration;
    propertyDeclaration: (identifier: IAstNode, value: IAstNode, initializer: IAstNode, start: ISymbolPosition, end: ISymbolPosition) => IAstPropertyDeclaration;
    deconstructionAssignment: (variables: IAstNode, initializer: IAstNode, start: ISymbolPosition, end: ISymbolPosition) => IAstDeconstructingAssignment;
    classDeclaration: (name: IAstNode, contents: IAstNode[], start: ISymbolPosition, end: ISymbolPosition) => IAstClassDeclaration;
    breakStatement: (start: ISymbolPosition, end: ISymbolPosition) => IAstBreakStatement;
    continueStatement: (start: ISymbolPosition, end: ISymbolPosition) => IAstContinueStatement;
    blockStatement: (content: IAstNode[], start: ISymbolPosition, end: ISymbolPosition, withoutBraces?: boolean) => IAstBlockStatement;
    ifStatement: (condition: IAstNode, thenValue: IAstNode, elseValue: IAstNode, start: ISymbolPosition, end: ISymbolPosition) => IAstIfStatement;
    switchStatement: (condition: IAstNode, cases: IAstNode[], start: ISymbolPosition, end: ISymbolPosition) => IAstSwitchStatement;
    caseStatement: (condition: IAstNode, body: IAstNode[], consequent: IAstNode, start: ISymbolPosition, end: ISymbolPosition) => IAstCaseStatement;
    whileStatement: (condition: IAstNode, body: IAstNode, start: ISymbolPosition, end: ISymbolPosition) => IAstWhileStatement;
    doWhileStatement: (condition: IAstNode, body: IAstNode, start: ISymbolPosition, end: ISymbolPosition) => IAstDoWhileStatement;
    forStatement: (init: IAstNode, test: IAstNode, update: IAstNode, body: IAstNode, start: ISymbolPosition, end: ISymbolPosition) => IAstForStatement;
    forInStatement: (left: IAstNode, right: IAstNode, body: IAstNode, start: ISymbolPosition, end: ISymbolPosition) => IAstForInStatement;
    forOfStatement: (left: IAstNode, right: IAstNode, body: IAstNode, start: ISymbolPosition, end: ISymbolPosition) => IAstForInStatement;
    importStatement: (identifier: IAstNode, importInContext: boolean, path: IAstNode, start: ISymbolPosition, end: ISymbolPosition) => IAstImportStatement;
    rawImportStatement: (identifier: IAstNode | IAstNode[], path: IAstNode, start: ISymbolPosition, end: ISymbolPosition) => IAstRawImportStatement;
    importItem: (identifier: IAstNode, alias: IAstNode, start: ISymbolPosition, end: ISymbolPosition) => IAstImportItem;
    tryStatement: (body: IAstNode, catchClause: IAstNode, finallyBlock: IAstNode, start: ISymbolPosition, end: ISymbolPosition) => IAstTryStatement;
    catchStatement: (body: IAstNode, varDeclaration: IAstNode, start: ISymbolPosition, end: ISymbolPosition) => IAstCatchStatement;
    finallyStatement: (body: IAstNode, start: ISymbolPosition, end: ISymbolPosition) => IAstFinallyStatement;
    throwStatement: (expression: IAstNode, start: ISymbolPosition, end: ISymbolPosition) => IAstThrowStatement;
    keywordNode: (keyword: IAstKeyword, node: IAstNode, isKeywordFirst: boolean, start: ISymbolPosition, end: ISymbolPosition) => IAstKeywordNode;
    parenExpression: (expression: IAstNode, start: ISymbolPosition, end: ISymbolPosition) => IAstParenExpression;
    objectLiteral: (properties: IAstNode[], start: ISymbolPosition, end: ISymbolPosition) => IAstObject;
    callExpression: (calee: IAstNode, args: IAstNode[], start: ISymbolPosition, end: ISymbolPosition) => IAstCallExpression;
    updateExpression: (argument: IAstNode, operator: IAstNode, prefix: boolean, start: ISymbolPosition, end: ISymbolPosition) => IAstUpdateExpression;
    binaryExpression: (left: IAstNode, operator: IAstNode, right: IAstNode, start: ISymbolPosition, end: ISymbolPosition) => IAstBinaryExpression;
    memberExpression: (object: IAstNode, property: IAstNode, optional: boolean, start: ISymbolPosition, end: ISymbolPosition) => IAstMemberExpression;
    IndexerExpression: (member: IAstMemberExpression, start: ISymbolPosition, end: ISymbolPosition) => IAstIndexerExpression;
    conditionalExpression: (condition: IAstNode, whenTrue: IAstNode, whenFalse: IAstNode, colonToken: IAstNode, questionToken: IAstNode, start: ISymbolPosition, end: ISymbolPosition) => IAstConditionalExpression;
    outerStatement: (indent: number, statement: IAstNode, start: ISymbolPosition, end: ISymbolPosition) => IAstOuterStatement;
    textLineStatement: (indent: number, text: IAstNode[], start: ISymbolPosition, end: ISymbolPosition) => IAstTextLineStatement;
    objectLineStatement: (object: IAstNode, value: IAstNode, tags: IAstNode[], start: ISymbolPosition, end: ISymbolPosition) => IAstObjectLineStatement;
    stringIncludeStatement: (expression: IAstNode, start: ISymbolPosition, end: ISymbolPosition) => IAstStringIncludeStatement;
    prototypeExpression: (value: IAstNode, start: ISymbolPosition, end: ISymbolPosition) => IAstPrototypeExpression;
    deleteLineExpression: (object: IAstNode, start: ISymbolPosition, end: ISymbolPosition) => IAstDeleteLineExpression;
    scope: (content: IAstNode[], open: IAstNode, close: IAstNode, start: ISymbolPosition, end: ISymbolPosition) => IAstScope;
    tag: (content: IAstNode[], open: IAstNode, close: IAstNode, start: ISymbolPosition, end: ISymbolPosition) => IAstScope;
    asNode: <TAst extends IAstNode>(ast: IAstNode, nodeType: AstNodeType) => TAst;
};
